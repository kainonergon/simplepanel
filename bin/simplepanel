#! /bin/dash
#
# simplepanel
#
# Simple panel script for bspwm with lemonbar
# Inspired by limepanel https://github.com/Chrysostomus/limepanel
# Dash version

# Kill any older panel processes

while [ $(pgrep -cx simplepanel) -gt 1 ] ; do pkill -ox -9 simplepanel ; done ;
while [ $(pgrep -cx lemonbar) -gt 0 ] ; do pkill -ox -9 lemonbar ; done ;
while [ $(pgrep -cx xtitle) -gt 0 ] ; do pkill -ox -9 xtitle ; done ;
while [ $(pgrep -cx bspc) -gt 0 ] ; do pkill -ox -9 bspc ; done ;
while [ $(pgrep -cx xkb-switch) -gt 0 ] ; do pkill -ox -9 xkb-switch ; done ;

if ! [ -f "$HOME/.simplepanelrc" ] || [ "$1" = '--reset' ] ; then	# write default configuration file
    cat > "$HOME/.simplepanelrc"<<"_EOF_"
#! /bin/dash
#
# .simplepanelrc
#
# Configuration for simplepanel
# In order to reset configuration to defaults
# delete this file or use --reset option

# Set size and position

SP_WIDTH=""
SP_HEIGHT=28
SP_POSITION=""
SP_BOTTOM=""	# if set to "-b" panel will be at the bottom of the screen, if set to "" - at the top

# Set fonts

# SP_FONT_1="xos4 Terminus:pixelsize=18"			# main font - with xft
SP_FONT_1='-*-terminus-medium-r-*--18-*-*-*-*-*-iso10646-1'	# without xft
SP_OFFSET_1=-2

SP_FONT_2="Ionicons:pixelsize=24"				# font for "icons" - with xft
# SP_FONT_2='-*-ionicons-medium-r-*--24-*-*-*-*-*-iso10646-1'	# without xft
SP_OFFSET_2=0

SP_FONT_3="mono:pixelsize=18"					# fallback font - with xft
# SP_FONT_3='-*-dejavu sans mono-medium-r-*--18-*-*-*-*-*-iso10646-1'	# without xft
SP_OFFSET_3=-2

# Set colors

SP_BG_COLOR="#FFEFF0F1"		# default background color
SP_BG_COLOR_1="#FF3DAEE9"	# alternative background color

SP_FG_COLOR="#FF101010"		# default foreground color
SP_FG_COLOR_1="#FFB6B8BA"	# alternative foreground color 1 - light
SP_FG_COLOR_2="#FF5C616C"	# alternative foreground color 2 - dark
SP_FG_COLOR_3="red"		# alternative foreground color 3 - urgent

# Set update interval (in seconds) for clock, wifi etc.

UPD_INT=3

# Directory for temporary files

TMP="/tmp/simplepanel/"

# Set lemonbar format codes. See more at https://github.com/LemonBoy/bar

BC='%{B-}'			# use default background color
BC1="%{B$SP_BG_COLOR_1}"	# use alternative background color

FC='%{F-}'			# use default foreground color
FC1="%{F$SP_FG_COLOR_1}"	# use alternative foreground color 1 - light
FC2="%{F$SP_FG_COLOR_2}"	# use alternative foreground color 2 - dark
FC3="%{F$SP_FG_COLOR_3}"	# use alternative foreground color 3 - urgent

LEFT="%{c}"			# left text alignment
CENTER="%{c}"			# center text alignment
RIGHT="%{r}"			# right text alignment

SEPARATOR="$FC1 ▏$FC"

# Set panel structure
# Provide a string with a list of panel modules (blocks)
# Separate module names by spaces or newlines
# Modules will appear on the panel in the given order
# Add your own modules as you wish

sp_modules="
sp_main_menu
sp_separator
sp_bspwm_status
sp_separator
sp_window_title
sp_center
sp_right
sp_separator
sp_xkb_layout
sp_status
"

# Module definitions
# Every module gets its index as a positional parameter
# A module shoud print this index in the beginning of the line
# If contents of a module do not change (button, separator, etc.) it should print one line and exit
# If contents of a module change (window title, clock, etc.) it should print one line for every new value
# The panel updates every time a module prints a line
# Write your own modules as you wish

sp_main_menu()
{
	ICON="${FC2}%{T2} %{T1}${FC}" ;
	COMMAND_1="morc_menu" ;

	echo "$1%{A1:$COMMAND_1:}${ICON}%{A1}" ;
}

sp_separator()
{
	echo "$1$SEPARATOR" ;
}

sp_center()
{
	echo "$1$CENTER" ;
}

sp_right()
{
	echo "$1$RIGHT" ;
}

sp_bspwm_status()
{
	COMMAND_1="bspc desktop -f next.occupied" ;	# focus next occupied desktop
	COMMAND_2="bspc desktop -f prev.occupied" ;	# focus previous occupied desktop
	COMMAND_3="bspc desktop -f last" ;		# focus last focused desktop
	COMMAND_4="bspc desktop -f " ;			# focus desktop
	COMMAND_5="bspc desktop -l next" ;		# switch to the next layout (tiling or monocle)

	index="$1"

	i=10 ;
	while ! bspc wm -g > /dev/null && [ $i -gt 0 ] ; do	# wait while bspwm starts
		sleep 0.5 ;
		i=$(($i-1)) ;
	done ;
	if [ $i -eq 0 ] ; then
		echo "${index}no bspwm" ;
		exit ;			# exit if bspwm does not respond
	fi ;

	bspc subscribe \
	| {
		IFS=':' ;
		while read line ; do
			status_line="$index%{A4:$COMMAND_1:}%{A5:$COMMAND_2:}" ;
				set -- $line ;
				while [ $# -gt 0 ] ; do
					desktop="${1#?}" ;
					case $1 in
						O*|F*|U*)	# highlight focused desktop (occupied, free or urgent)
							status_line="$status_line$BC1%{A1:$COMMAND_3:} $desktop %{A1}$BC" ;;
						o*|u*)		# show unfocused desktops (occupied or urgent)
							status_line="$status_line%{A1:$COMMAND_4$desktop:} $desktop %{A1}" ;;
						L*)		# show current layout (tiling or monocle)
							status_line="$status_line%{A1:$COMMAND_5:} $desktop %{A1}" ;;
					esac ;
					shift ;
				done ;
			echo "$status_line" ;
		done ;
	}
}

sp_window_title()
{
	COMMAND_1="MonocleSwitcher" ;

	xtitle -s -t -50 -f "$1%{A1:$COMMAND_1:}%s%{A1}\n" ;
}

sp_xkb_layout()
{
	ICON="$FC2%{T2}$FC%{T1}" ;
	COMMAND_1="xkb-switch -n" ;

	while true; do
		echo "$1%{A1:$COMMAND_1:}$ICON $(xkb-switch)%{A1}" ;
		xkb-switch -w ;
	done ;
}

# Modules with _once in the name do not loop so they can be combined into one status line
# If combined they will update all together thus using less resources

# Set status line structure. Make sure these modules do not loop

sp_status_modules="
sp_wifi_once
sp_volume_once
sp_backlight_once
sp_battery_once
sp_clock_once
"

# status line module

sp_status()
{
	if [ -e "${TMP}update_status_now" ] ; then
		rm "${TMP}update_status_now" ;
	fi ;
	mkfifo "${TMP}update_status_now" ;

	while true ; do
		printf "\n" > "${TMP}update_status_now" ;
		sleep "$UPD_INT" ;
	done &

	while read line < "${TMP}update_status_now"; do
		status_line="$1" ;
		for status_module in $sp_status_modules ; do
			status_line="$status_line$SEPARATOR$($status_module)" ;
		done
		echo "$status_line" ;
	done ;
}

# wifi module for status line

sp_wifi_once()
{
	COMMAND_3="terminal -e nmtui" ;		# run network manager text based UI

	WIFI_INT="$(ip link show | awk '/state UP/ {print substr($2, 1, length($2)-1)}')" ;	# wireless interface name
	printf "%s" "%{A3:$COMMAND_3:}" ;
	if [ -d /sys/class/net/${WIFI_INT}/wireless ] && [ "$(cat /sys/class/net/$WIFI_INT/operstate)" != 'down' ] ; then
		WIFI_QUALITY=$(awk 'NR==3 {print int($3 * 100 / 70)}' /proc/net/wireless) ;
		WIFI_NAME=$(iwgetid -r) ;
		case $(( $WIFI_QUALITY / 20 )) in
			5|4)	WIFI_BARS="$FC2▂▄▆█$FC" ;;
			3)	WIFI_BARS="$FC2▂▄▆_$FC" ;;
			2)	WIFI_BARS="$FC2▂▄__$FC" ;;
			1)	WIFI_BARS="$FC3▂___$FC" ;;
			*)	WIFI_BARS="$FC3____$FC" ;;
		esac ;
		printf "%s %s" "$WIFI_BARS" "$WIFI_NAME" ;
	else
		printf "no wifi" ;
	fi ;
	printf "%s\n" "%{A3}" ;
}

# battery module for status line

sp_battery_once()
{
	ICON_1="$FC2%{T2}%{T1}$FC" ;	# charging
	ICON_2="$FC2%{T2}%{T1}$FC" ;	# full
	ICON_3="$FC2%{T2}%{T1}$FC" ;	# almost full
	ICON_4="$FC2%{T2}%{T1}$FC" ;	# almost empty
	ICON_5="$FC3%{T2}%{T1}$FC" ;	# empty

	COMMAND_3="xfce4-power-manager -c" ;
	COMMAND_4="backlight_up" ;
	COMMAND_5="backlight_down" ;

	if !  [ -e /sys/class/power_supply/BAT*/ ] ; then
		exit ;
	fi ;

	BAT_CAP="$(cat /sys/class/power_supply/BAT*/capacity)" ;
	BAT_STAT="$(cat /sys/class/power_supply/BAT*/status)" ;

	printf "%s" "%{A3:$COMMAND_3:}%{A4:$COMMAND_4:}%{A5:$COMMAND_5:}" ;
	if [ "$BAT_STAT" = "Charging" ] ; then
		printf "%s" "$ICON_1 $BAT_CAP%" ;
	else
		case $(( $BAT_CAP / 25 )) in
			4|3)	printf "%s" "$ICON_2 $BAT_CAP%" ;;
			2)	printf "%s" "$ICON_3 $BAT_CAP%" ;;
			1)	printf "%s" "$ICON_4 $BAT_CAP%" ;;
			*)	printf "%s" "$ICON_5 $BAT_CAP%" ;;
		esac ;
	fi ;
	printf "%s\n" "%{A5}%{A4}%{A3}" ;
}

# backlight module for status line

backlight_down()
{
	BL_STAT="$(xbacklight -get)" ;
	if [ ${BL_STAT%%.*} -gt 6 ] ; then		# make sure backlight is not too low
		xbacklight -time 10 -steps 10 "-5" ;
	fi ;
	printf "\n" > "${TMP}update_status_now" ;
}

backlight_up()
{
	xbacklight -time 10 -steps 10 "+5" ;
	printf "\n" > "${TMP}update_status_now" ;
}

sp_backlight_once()
{
	ICON="$FC2%{T2}$FC%{T1}" ;

	COMMAND_4="backlight_up" ;
	COMMAND_5="backlight_down" ;

	if ! [ -e /sys/class/backlight/ ] ; then	# exit if no backlight is present
		exit ;
	fi ;

	BL_STAT="$(xbacklight -get)" ;
	BL_STAT="${BL_STAT%%.*}" ;
	case $(( $BL_STAT / 11 )) in
		9|8) BL_BAR='█' ;;
		7) BL_BAR='▇' ;;
		6) BL_BAR='▆' ;;
		5) BL_BAR='▅' ;;
		4) BL_BAR='▄' ;;
		3) BL_BAR='▃' ;;
		2) BL_BAR='▂' ;;
		1) BL_BAR='▁' ;;
		*) BL_BAR=' ' ;;
	esac ;
	printf "%s%s %s%s\n" "%{A4:$COMMAND_4:}%{A5:$COMMAND_5:}" "$ICON" "$FC2$BL_BAR$FC" "%{A5}%{A4}" ;
}

# clock module for status line

show_date_toggle()
{
	if [ -f "${TMP}show_date_toggle" ] ; then
		rm "${TMP}show_date_toggle" ;
	else
		touch "${TMP}show_date_toggle" ;
	fi ;
	printf "\n" > "${TMP}update_status_now" ;
}

sp_clock_once()
{
	ICON_CLOCK="$FC2%{T2}$FC%{T1}" ;
	ICON_DATE="$FC2%{T2}$FC%{T1}" ;

	COMMAND_1="show_date_toggle"

	printf "%s" "%{A1:$COMMAND_1:}" ;
	if [ -f "${TMP}show_date_toggle" ] ; then
		printf "%s %s%s" "$ICON_DATE" "$(date '+%x')" "$SEPARATOR" ;	# print date
	fi ;

	printf "%s %s %s\n" "$ICON_CLOCK" "$(date '+%R')" "%{A1}" ;		# print time
}

# sound volume module for status line

volume_get_level()
{
	amixer get Master | sed -n 's/^.*\[\([0-9]\+\)%.*$/\1/p' | head -n 1 ;
}

volume_get_state()
{
	amixer get Master | sed -n 's/^.*\[\(o[nf]\+\).*$/\1/p' | head -n 1 ;
}

volume_toggle()
{
	amixer set Master toggle ;
	printf "\n" > "${TMP}update_status_now" ;
}

volume_up()
{
	amixer set Master 5%+ ;
	printf "\n" > "${TMP}update_status_now" ;
}

volume_down()
{
	amixer set Master 5%- ;
	printf "\n" > "${TMP}update_status_now" ;
}

sp_volume_once()
{
	ICON_1="$FC2%{T2}$FC%{T1}" ;	# mute
	ICON_2="$FC2%{T2}$FC%{T1}" ;	# low
	ICON_3="$FC2%{T2}$FC%{T1}" ;	# medium
	ICON_4="$FC2%{T2}$FC%{T1}" ;	# high

	COMMAND_1="volume_toggle" ;
	COMMAND_3="terminal -e alsamixer" ;
	COMMAND_4="volume_up" ;
	COMMAND_5="volume_down" ;

	VOL_LEVEL="$(volume_get_level)" ;
	case $(( $VOL_LEVEL / 11 )) in
		9|8) VOL_BAR='█'; ICON="$ICON_4" ;;
		7) VOL_BAR='▇'	; ICON="$ICON_4" ;;
		6) VOL_BAR='▆'	; ICON="$ICON_4" ;;
		5) VOL_BAR='▅'	; ICON="$ICON_3" ;;
		4) VOL_BAR='▄'	; ICON="$ICON_3" ;;
		3) VOL_BAR='▃'	; ICON="$ICON_3" ;;
		2) VOL_BAR='▂'	; ICON="$ICON_2" ;;
		1) VOL_BAR='▁'	; ICON="$ICON_2" ;;
		*) VOL_BAR=' '	; ICON="$ICON_2" ;;
	esac ;
	if [ "$(volume_get_state)" = "off" ] ; then
		ICON="$ICON_1" ;
	fi ;
	printf "%s%s %s%s\n" "%{A1:$COMMAND_1:}%{A3:$COMMAND_3:}%{A4:$COMMAND_4:}%{A5:$COMMAND_5:}" "$ICON" "$FC2$VOL_BAR$FC" "%{A5}%{A4}%{A3}%{A1}" ;
}
_EOF_
fi ;

. "$HOME/.simplepanelrc" ;  # read configuration file

##########
## MAIN ##
##########

#### INITIALIZE PANEL ####

# create directory for temporary files

if ! [ -d "$TMP" ] ; then
	mkdir "$TMP" ;
fi ;

# set initial empty values

sp_values="" ;
for module in $sp_modules ; do
	sp_values="$sp_values\n" ;
done ;

# start modules in the background and pipe them to the panel

i=0 ;
for module in $sp_modules ; do
	"$module" "$i/" &
	sleep 0.05 ;
	i=$(( $i+1 )) ;
done \
| { 

#### UPDATE PANEL ####

	IFS="\n" ;			# needed to preserve initial and final spaces
	while read line ; do		# update panel every time a module prints a line
		index="${line%%/*}" ;	# get index of the module that needs update
		i=0 ;
		sp_values_new="" ;
		while [ -n "$sp_values" ] ; do			# read stored set of values
			if [ $i -eq $index ] ; then
				value="$line" ;			# replace appropriate value
			else
				value="${sp_values%%\\n*}" ;	# keep all other values
			fi
			sp_values="${sp_values#*\\n}" ;		# remove old stored value
			sp_values_new="$sp_values_new$value\n" ;	# store new value
			value="${value#*/}" ;			# remove index from current value
			printf "%s" "${value}" ;		# print current value
			i=$(( $i+1 )) ;
		done ;
		printf "\n" ;			# end the line to update lemonbar
		sp_values="$sp_values_new" ;	# replace old set of values with new one
		sleep 0.05 ;			# a delay needed for smooth updates (lemonbar bug?)
	done ;
} | lemonbar \
	-g "${SP_WIDTH}x${SP_HEIGHT}${SP_POSITION}" \
	-f "$SP_FONT_1" -o "$SP_OFFSET_1" \
	-f "$SP_FONT_2" -o "$SP_OFFSET_2" \
	-f "$SP_FONT_3" -o "$SP_OFFSET_3" \
	-B "$SP_BG_COLOR" \
	-F "$SP_FG_COLOR" \
	"$SP_BOTTOM" \
| while read line ; do
	eval "$line"	# execute commands for clickable areas of lemonbar
done ;

