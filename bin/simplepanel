#! /bin/dash
#
# simplepanel
#
# Simple panel script for bspwm with lemonbar
# Inspired by limepanel https://github.com/Chrysostomus/limepanel
# Dash version

# Kill any older panel processes

while [ $(pgrep -cx simplepanel) -gt 1 ] ; do pkill -ox -9 simplepanel ; done ;
while [ $(pgrep -cx lemonbar) -gt 0 ] ; do pkill -ox -9 lemonbar ; done ;
while [ $(pgrep -cx xtitle) -gt 0 ] ; do pkill -ox -9 xtitle ; done ;
while [ $(pgrep -cx bspc) -gt 0 ] ; do pkill -ox -9 bspc ; done ;
while [ $(pgrep -cx xkb-switch) -gt 0 ] ; do pkill -ox -9 xkb-switch ; done ;

if ! [ -f "$HOME/.simplepanelrc" ] || [ "$1" = '--reset' ] ; then	# write default configuration file
    cat > "$HOME/.simplepanelrc"<<"_EOF_"
#! /bin/dash
#
# .simplepanelrc
#
# Configuration for simplepanel
# In order to reset configuration to defaults
# delete this file or use --reset option

# Set size and position

SP_WIDTH=""
SP_HEIGHT=28
SP_POSITION=""
SP_BOTTOM=""	# if set to "-b" panel will be at the bottom of the screen, if set to "" - at the top

# Set fonts

# SP_FONT_1="xos4 Terminus:pixelsize=18"			# main font - with xft
SP_FONT_1='-*-terminus-medium-r-*--18-*-*-*-*-*-iso10646-1'	# without xft
SP_OFFSET_1=-2

SP_FONT_2="Ionicons:pixelsize=24"				# font for "icons" - with xft
# SP_FONT_2='-*-ionicons-medium-r-*--24-*-*-*-*-*-iso10646-1'	# without xft
SP_OFFSET_2=0

SP_FONT_3="mono:pixelsize=18"					# fallback font - with xft
# SP_FONT_3='-*-dejavu sans mono-medium-r-*--18-*-*-*-*-*-iso10646-1'	# without xft
SP_OFFSET_3=-2

# Set colors

SP_BG_COLOR="#FFEFF0F1"		# default background color
SP_BG_COLOR_1="#FF3DAEE9"	# alternative background color

SP_FG_COLOR="#FF101010"		# default foreground color
SP_FG_COLOR_1="#FFB6B8BA"	# alternative foreground color 1 - light
SP_FG_COLOR_2="#FF5C616C"	# alternative foreground color 2 - dark
SP_FG_COLOR_3="red"		# alternative foreground color 3 - urgent

# Set update interval (in seconds) for status line

UPD_INT=3

# Directory for temporary files

TMP="/tmp/simplepanel/"

# Set lemonbar format codes. See more at https://github.com/LemonBoy/bar

BC='%{B-}'			# use default background color
BC1="%{B$SP_BG_COLOR_1}"	# use alternative background color

FC='%{F-}'			# use default foreground color
FC1="%{F$SP_FG_COLOR_1}"	# use alternative foreground color 1 - light
FC2="%{F$SP_FG_COLOR_2}"	# use alternative foreground color 2 - dark
FC3="%{F$SP_FG_COLOR_3}"	# use alternative foreground color 3 - urgent

LEFT="%{c}"			# left text alignment
CENTER="%{c}"			# center text alignment
RIGHT="%{r}"			# right text alignment

SEPARATOR="$FC1 ▏$FC"

# Set panel structure
# Provide a string with a list of panel modules (blocks)
# Separate module names by spaces or newlines
# Modules will appear on the panel in the given order
# Add your own modules as you wish

sp_modules="
sp_menu
sp_separator
sp_bspwm
sp_separator
sp_title
sp_center
sp_right
sp_separator
sp_xkb
sp_separator
sp_status
"

# Module definitions
# Every module gets its index as a positional parameter
# A module shoud print this index followed by : in the beginning of the line (echo "$1:some text")
# If contents of a module do not change (button, separator, etc.) it should print one line and exit
# If contents of a module change (window title, status line, etc.) it should print one line for every new value
# The panel updates every time any module prints a line
# Write your own modules as you wish

sp_menu()
{
	ICON="${FC2}%{T2} %{T1}${FC}" ;
	COMMAND_1="morc_menu" ;

	echo "$1:%{A1:$COMMAND_1:}${ICON}%{A1}" ;
}

sp_separator()
{
	echo "$1:$SEPARATOR" ;
}

sp_center()
{
	echo "$1:$CENTER" ;
}

sp_right()
{
	echo "$1:$RIGHT" ;
}

sp_bspwm()
{
	if ! which bspc > /dev/null ; then	# check if bspwm is installed
		echo "$1:no bspwm" ;
		exit ;
	fi ;

	i=50 ;
	while ! bspc wm -g > /dev/null && [ $i -gt 0 ] ; do	# wait while bspwm starts
		sleep 0.1 ;
		i=$(($i-1)) ;
	done ;
	if [ $i -eq 0 ] ; then
		echo "$1:no bspwm" ;
		exit ;					# exit if bspwm does not respond
	fi ;

	COMMAND_1="bspc desktop -f next.occupied" ;	# focus next occupied desktop
	COMMAND_2="bspc desktop -f prev.occupied" ;	# focus previous occupied desktop
	COMMAND_3="bspc desktop -f last" ;		# focus last focused desktop
	COMMAND_4="bspc desktop -f " ;			# focus desktop
	COMMAND_5="bspc desktop -l next" ;		# switch to the next layout (tiling or monocle)

	module_index="$1"

	bspc subscribe \
	| {
		IFS=':' ;
		while read line ; do
			bspwm_line="$module_index:%{A4:$COMMAND_1:}%{A5:$COMMAND_2:}" ;
				set -- $line ;
				while [ $# -gt 0 ] ; do
					desktop="${1#?}" ;
					case $1 in
						O*|F*|U*)	# highlight focused desktop (occupied, free or urgent)
							bspwm_line="$bspwm_line$BC1%{A1:$COMMAND_3:} $desktop %{A1}$BC" ;;
						o*|u*)		# show unfocused desktops (occupied or urgent)
							bspwm_line="$bspwm_line%{A1:$COMMAND_4$desktop:} $desktop %{A1}" ;;
						L*)		# show current layout (tiling or monocle)
							bspwm_line="$bspwm_line%{A1:$COMMAND_5:} $desktop %{A1}" ;;
					esac ;
					shift ;
				done ;
			echo "$bspwm_line" ;
		done ;
	}
}

sp_title()
{
	if ! which xtitle > /dev/null ; then		# check if xtitle is installed
		echo "$1:no xtitle" ;
		exit ;
	fi ;

	COMMAND_1="MonocleSwitcher" ;

	format="$1:%{A1:$COMMAND_1:}%s%{A1}\n" ;
	xtitle -s -t -50 -f "$format" ;
}

sp_xkb()
{
	if ! which xkb-switch > /dev/null ; then	# check if xkb-switch is installed
		echo "$1:no xkb-switch" ;
		exit ;
	fi ;

	ICON="$FC2%{T2}$FC%{T1}" ;
	COMMAND_1="xkb-switch -n" ;

	while true; do
		echo "$1:%{A1:$COMMAND_1:}$ICON $(xkb-switch)%{A1}" ;
		xkb-switch -w ;
	done ;
}

# status line module

sp_status()
{
	status_line_index=$1 ;
	
	IFS='
' ;

	while true ; do						# start timed status line update
		echo "all" > "${TMP}update_status_now" ;
		sleep "$UPD_INT" ;
	done &

	while read index < "${TMP}update_status_now"; do
		status_line="$status_line_index:" ;
		if [ $index = "all" ] ; then			# update all status modules
			sp_status_values="" ;
			i=0 ;
			for status_module in $sp_status_modules ; do
				value="$($status_module $i)" ;
				sp_status_values="$sp_status_values$value$IFS" ;	# store the value
				status_line="$status_line$value" ;			# add the value to the status line
				i=$(( $i+1 )) ;
			done ;
		else						# update one status module
			set -- $sp_status_modules ;
			shift $index ;
			new_value="$($1 $index)" ;
			set -- $sp_status_values ;
			i=0 ;
			sp_status_values="" ;
			while [ $# -gt 0 ] ; do			# read the old values
				if [ $i -eq $index ] ; then
					value="$new_value" ;	# replace the value that updates
				else
					value="$1" ;		# keep all other values
				fi
				sp_status_values="$sp_status_values$value$IFS" ;	# store the value
				status_line="$status_line$value" ;			# add the value to the status line
				i=$(( $i+1 )) ;
				shift ;		# remove old stored value
			done ;
		fi ;
		echo "$status_line" ;
	done ;
}

# Modules with _status in the name do not loop
# They can be combined into one status line that updates every $UPD_INT seconds
# First positional parameter is module index
# Modules for status line do not print their module index
# If the index is redirected to "${TMP}update_status_now" the module updates at once (e.g. volume change)

# Set status line structure

sp_status_modules="
sp_wifi_status
sp_separator_status
sp_volume_status
sp_separator_status
sp_backlight_status
sp_separator_status
sp_battery_status
sp_separator_status
sp_clock_status
"

# wifi module for status line

show_wifi_toggle()
{
	if [ -f "${TMP}show_wifi_toggle" ] ; then
		rm "${TMP}show_wifi_toggle" ;
	else
		touch "${TMP}show_wifi_toggle" ;
	fi ;
	echo "$1" > "${TMP}update_status_now" ;
}

sp_wifi_status()
{
	ICON="$FC2%{T2}%{T1}$FC" ;
	COMMAND_1="show_wifi_toggle $1" ;
	COMMAND_3="terminal -e nmtui" ;		# run network manager text based UI

	WIFI_INT="$(ip link show | awk '/state UP/ {print substr($2, 1, length($2)-1)}')" ;	# wireless interface name
	printf "%s" "%{A1:$COMMAND_1:}%{A3:$COMMAND_3:}$ICON " ;
	if [ -d /sys/class/net/${WIFI_INT}/wireless ] && [ "$(cat /sys/class/net/$WIFI_INT/operstate)" != 'down' ] ; then
		WIFI_QUALITY=$(awk 'NR==3 {print int($3 * 100 / 70)}' /proc/net/wireless) ;
		case $(( $WIFI_QUALITY / 20 )) in
			5|4)	WIFI_BARS="$FC2▂▄▆█$FC" ;;
			3)	WIFI_BARS="$FC2▂▄▆_$FC" ;;
			2)	WIFI_BARS="$FC2▂▄__$FC" ;;
			1)	WIFI_BARS="$FC3▂___$FC" ;;
			*)	WIFI_BARS="$FC3____$FC" ;;
		esac ;
		printf "%s" "$WIFI_BARS" ;
		if [ -f "${TMP}show_wifi_toggle" ] && which iwgetid > /dev/null ; then	# check if wifi name should be shown
			WIFI_NAME=$(iwgetid -r) ;
			printf "%s" " $WIFI_NAME" ;
		fi ;
	else
		printf "no wifi" ;
	fi ;
	printf "%s\n" "%{A3}%{A1}" ;
}

# battery module for status line

sp_battery_status()
{
	ICON_1="$FC2%{T2}%{T1}$FC" ;	# charging
	ICON_2="$FC2%{T2}%{T1}$FC" ;	# full
	ICON_3="$FC2%{T2}%{T1}$FC" ;	# almost full
	ICON_4="$FC2%{T2}%{T1}$FC" ;	# almost empty
	ICON_5="$FC3%{T2}%{T1}$FC" ;	# empty

	COMMAND_3="xfce4-power-manager -c" ;
	COMMAND_4="backlight_up" ;
	COMMAND_5="backlight_down" ;

	if !  [ -e /sys/class/power_supply/BAT*/ ] ; then
		exit ;
	fi ;

	BAT_CAP="$(cat /sys/class/power_supply/BAT*/capacity)" ;
	BAT_STAT="$(cat /sys/class/power_supply/BAT*/status)" ;

	printf "%s" "%{A3:$COMMAND_3:}%{A4:$COMMAND_4:}%{A5:$COMMAND_5:}" ;
	if [ "$BAT_STAT" = "Charging" ] ; then
		printf "%s" "$ICON_1 $BAT_CAP%" ;
	else
		case $(( $BAT_CAP / 25 )) in
			4|3)	printf "%s" "$ICON_2 $BAT_CAP%" ;;
			2)	printf "%s" "$ICON_3 $BAT_CAP%" ;;
			1)	printf "%s" "$ICON_4 $BAT_CAP%" ;;
			*)	printf "%s" "$ICON_5 $BAT_CAP%" ;;
		esac ;
	fi ;
	printf "%s\n" "%{A5}%{A4}%{A3}" ;
}

# backlight module for status line

backlight_down()
{
	if ! which xdotool > \dev\null ; then exit; fi ;	# check if xdotool is installed

	index=$1 ;
	if ! [ -z "$(ls /sys/class/backlight/)" ] ; then
		set -- /sys/class/backlight/* ;
		BL_STAT=$(( 100 * $(cat $1/actual_brightness) / $(cat $1/max_brightness) )) ;
		if [ $BL_STAT -gt 12 ] ; then		# make sure backlight is not too low
			xdotool key XF86MonBrightnessDown ;
		echo "$index" > "${TMP}update_status_now" ;
		fi ;
	fi ;
}

backlight_up()
{
	if ! which xdotool > \dev\null ; then exit; fi ;	# check if xdotool is installed

	xdotool key XF86MonBrightnessUp ;
	echo "$1" > "${TMP}update_status_now" ;
}

sp_backlight_status()
{
	ICON="$FC2%{T2}$FC%{T1}" ;

	COMMAND_4="backlight_up $1" ;
	COMMAND_5="backlight_down $1" ;

	if [ -z "$(ls /sys/class/backlight/)" ] ; then	# no backlight
		BL_STAT=-100 ;
	else
		set -- /sys/class/backlight/* ;
		BL_STAT=$(( 100 * $(cat $1/actual_brightness) / $(cat $1/max_brightness) )) ;
	fi ;
	case $(( $BL_STAT / 11 )) in
		9|8) BL_BAR='█' ;;
		7) BL_BAR='▇' ;;
		6) BL_BAR='▆' ;;
		5) BL_BAR='▅' ;;
		4) BL_BAR='▄' ;;
		3) BL_BAR='▃' ;;
		2) BL_BAR='▂' ;;
		1) BL_BAR='▁' ;;
		0) BL_BAR=' ' ;;
		*) BL_BAR='╳' ;; # no backlight
	esac ;
	echo "%{A4:$COMMAND_4:}%{A5:$COMMAND_5:}$ICON $FC2$BL_BAR$FC%{A5}%{A4}" ;
}

# clock module for status line

show_date_toggle()
{
	if [ -f "${TMP}show_date_toggle" ] ; then
		rm "${TMP}show_date_toggle" ;
	else
		touch "${TMP}show_date_toggle" ;
	fi ;
	printf "$1\n" > "${TMP}update_status_now" ;
}

sp_clock_status()
{
	ICON_CLOCK="$FC2%{T2}$FC%{T1}" ;
	ICON_DATE="$FC2%{T2}$FC%{T1}" ;

	COMMAND_1="show_date_toggle $1"

	printf "%s" "%{A1:$COMMAND_1:}" ;
	if [ -f "${TMP}show_date_toggle" ] ; then
		printf "%s %s%s" "$ICON_DATE" "$(date '+%x')" "$SEPARATOR" ;	# print date
	fi ;

	printf "%s %s %s\n" "$ICON_CLOCK" "$(date '+%R')" "%{A1}" ;		# print time
}

# sound volume module for status line

volume_get_level()
{
	amixer get Master | sed -n 's/^.*\[\([0-9]\+\)%.*$/\1/p' | head -n 1 ;
}

volume_get_state()
{
	amixer get Master | sed -n 's/^.*\[\(o[nf]\+\).*$/\1/p' | head -n 1 ;
}

volume_toggle()
{
	amixer set Master toggle ;
	printf "$1\n" > "${TMP}update_status_now" ;
}

volume_up()
{
	amixer set Master 5%+ ;
	printf "$1\n" > "${TMP}update_status_now" ;
}

volume_down()
{
	amixer set Master 5%- ;
	printf "$1\n" > "${TMP}update_status_now" ;
}

sp_volume_status()
{
	if ! which amixer > /dev/null ; then		# chech if amixer is installed
		echo "no amixer" ;
		exit ;
	fi ;

	ICON_1="$FC2%{T2}$FC%{T1}" ;	# mute
	ICON_2="$FC2%{T2}$FC%{T1}" ;	# low
	ICON_3="$FC2%{T2}$FC%{T1}" ;	# medium
	ICON_4="$FC2%{T2}$FC%{T1}" ;	# high

	COMMAND_1="volume_toggle $1" ;
	COMMAND_3="terminal -e alsamixer" ;
	COMMAND_4="volume_up $1" ;
	COMMAND_5="volume_down $1" ;

	VOL_LEVEL="$(volume_get_level)" ;
	case $(( $VOL_LEVEL / 11 )) in
		9|8) VOL_BAR='█'; ICON="$ICON_4" ;;
		7) VOL_BAR='▇'	; ICON="$ICON_4" ;;
		6) VOL_BAR='▆'	; ICON="$ICON_4" ;;
		5) VOL_BAR='▅'	; ICON="$ICON_3" ;;
		4) VOL_BAR='▄'	; ICON="$ICON_3" ;;
		3) VOL_BAR='▃'	; ICON="$ICON_3" ;;
		2) VOL_BAR='▂'	; ICON="$ICON_2" ;;
		1) VOL_BAR='▁'	; ICON="$ICON_2" ;;
		*) VOL_BAR=' '	; ICON="$ICON_2" ;;
	esac ;
	if [ "$(volume_get_state)" = "off" ] ; then
		ICON="$ICON_1" ;
	fi ;
	printf "%s%s %s%s\n" "%{A1:$COMMAND_1:}%{A3:$COMMAND_3:}%{A4:$COMMAND_4:}%{A5:$COMMAND_5:}" "$ICON" "$FC2$VOL_BAR$FC" "%{A5}%{A4}%{A3}%{A1}" ;
}

sp_separator_status()
{
	echo "$SEPARATOR" ;
}
_EOF_
fi ;

. "$HOME/.simplepanelrc" ;  # read configuration file

##########
## MAIN ##
##########


#### INITIALIZE PANEL ####

# create directory for temporary files

if ! [ -d "$TMP" ] ; then
	mkdir "$TMP" ;
fi ;

# create fifo for status line updates

if [ -e "${TMP}update_status_now" ] ; then
	rm "${TMP}update_status_now" ;
fi ;
mkfifo "${TMP}update_status_now" ;

# set initial empty values

for module in $sp_modules ; do
	sp_values="$sp_values 
" ;
done ;

# start modules in the background and pipe them to the panel

index=0 ;
for module in $sp_modules ; do
	"$module" "$index" &
	index=$(( $index+1 )) ;
done \
| { 

#### UPDATE PANEL ####

IFS='
' ;					# needed to preserve initial and final spaces
	while read line ; do		# update panel every time a module prints a line
		index="${line%%:*}" ;	# get index of the module that needs update
		new_value="${line#*:}" ;	# get new value of the module that needs update
		set -- $sp_values ;	# set positional parameters to the old values
		sp_values="" ;		# initial set of new values
		panel_line="" ;
		i=0 ;
		while [ $# -gt 0 ] ; do				# read the old values
			if [ $i -eq $index ] ; then
				value="$new_value" ;		# replace the value that updates
			else
				value="$1" ;			# keep all other values
			fi
			sp_values="$sp_values$value$IFS" ;	# store the new value
			panel_line="$panel_line$value" ;	# and add it to the panel line
			i=$(( $i+1 )) ;
			shift ;
		done ;
		echo "$panel_line" ;	# print the panel line to update lemonbar
		sleep 0.03 ;		# a delay needed for smooth updates (lemonbar bug?)
	done ;
} | lemonbar \
	-g "${SP_WIDTH}x${SP_HEIGHT}${SP_POSITION}" \
	-f "$SP_FONT_1" -o "$SP_OFFSET_1" \
	-f "$SP_FONT_2" -o "$SP_OFFSET_2" \
	-f "$SP_FONT_3" -o "$SP_OFFSET_3" \
	-B "$SP_BG_COLOR" \
	-F "$SP_FG_COLOR" \
	"$SP_BOTTOM" \
| while read line ; do
	eval "$line"	# execute commands for clickable areas of lemonbar
done ;

